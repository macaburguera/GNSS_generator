function x = jammer_factory(P, fs, N)
%JAMMER_FACTORY  Generate jammer waveform (complex baseband).
% Supports: NoJam, CW, CWcomb, Chirp, PRN, NB, WB, FH, Composite
%
% Input P is a struct with the same fields you used before.
% New (optional) section for realistic front-end artifacts:
%   P.frontend.enable               (false by default)
%   P.frontend.dc_offset            (complex, e.g., 1e-3 + 1e-3j)
%   P.frontend.iq_gain_imbalance_dB (e.g., 0.2)
%   P.frontend.iq_phase_deg         (e.g., 1.5)
%   P.frontend.softclip_dBFS        (e.g., -1.5)  % ~AGC/limiter
%   P.frontend.amp_flicker_dB       (e.g., 0.5)   % slow AM p-p
%   P.frontend.spurs.enable         (true/false)
%   P.frontend.spurs.count          (e.g., 2..4)
%   P.frontend.spurs.rel_dB         (e.g., -28)
%   P.frontend.spurs.bw_Hz          ([0.3e6 2e6]) for small swept spurs
%   P.frontend.phase_noise.L_dBc_Hz (e.g., -85 @ 1 kHz)  % simple one-point spec
%   P.frontend.phase_noise.f0_Hz    (offset for the spec, e.g., 1e3)
%
% NOTE: The front-end block is applied BEFORE the final unit-power
% normalization so its spectral “shape” is preserved but absolute power
% is removed (as your Channel scales to JSR anyway).
Fs = fs;  % alias for clarity—MATLAB is case-sensitive

t  = (0:N-1).'/fs;
typ = lower(fget(P,'type','nojam'));

switch typ

    case 'nojam'
        % Pure “no jammer” (zeros). If you want realistic NoJam *front-end*
        % artifacts in the *jammer path*, you can enable P.frontend.enable.
        x = complex(zeros(N,1));

    % -------- CW single tone with optional drift/flicker --------
    case 'cw'
        f0   = fget(P,'tone_offset_Hz',0);
        fdot = fget(P,'freq_drift_Hzps',0);        % Hz/s
        Aflk = fget(P,'amp_flicker_dB',0);         % dB p-p slow AM
        f_t  = f0 + fdot*(t - t(1));
        phi  = 2*pi*cumsum(f_t)/fs;
        x    = exp(1j*phi);
        if Aflk>0
            m   = 10^(Aflk/20);
            env = 1 + (m-1)*sin(2*pi*200*t);       % very slow AM
            x   = x .* env;
        end

    % -------- CW multi-tone comb --------
    case 'cwcomb'
        offs = fget(P,'offsets_Hz',[-5e6 0 5e6]);
        x = zeros(N,1);
        for k=1:numel(offs), x = x + exp(1j*2*pi*offs(k)*t); end

    % ---------------- PRN/BPSK (generic NB/WB) ----------------
    case {'prn','nb','wb'}
        % accept both “rate_Hz” and legacy “chip_rate_Hz”
        Rchip = fget(P,'rate_Hz',fget(P,'chip_rate_Hz',2e6));
        ro    = fget(P,'rolloff',0.2);
        filt  = lower(fget(P,'filter','rrc'));    % 'rrc' or 'rect'
        fOff  = fget(P,'osc_offset_Hz',0);
    
        spc   = max(2, round(fs/Rchip));         % samples per chip
    
        % Optional periodicity (e.g., 9 Mcps with 1 ms repetition)
        perT        = fget(P,'periodicity_s',0);
        hasPeriod   = (perT > 0);
        chipsPer    = 0;
        if hasPeriod
            chipsPer = max(1, round(perT * Rchip));  % e.g., 9000 for 9e6 * 1e-3
        end
    
        % Length needed to safely cover the tile after upsampling
        % (N/spc chips plus a cushion). Also ensure >= chipsPer when periodic.
        Lchips_need = ceil(N / spc) + 100;
        Lchips_eff  = max(Lchips_need, chipsPer);
    
        % Generate base PN chips
        chips = 2*randi([0,1], Lchips_eff, 1) - 1;   % ±1
    
        % Force periodic repetition if requested
        if hasPeriod
            % Repeat the first 'chipsPer' chips to fill Lchips_eff
            reps  = ceil(Lchips_eff / chipsPer);
            chips = repmat(chips(1:chipsPer), reps, 1);
            chips = chips(1:Lchips_eff);             % trim exact
        end
    
        % Upsample to waveform
        s  = upsample(chips, spc);
    
        % Shape it
        switch filt
            case 'rrc'
                try
                    h = firrcos(128, Rchip/2, ro, fs, 'rolloff', 'sqrt');
                catch
                    fc = min(0.49, ((Rchip*(1+ro)/2)/(fs/2)));
                    h  = fir1(128, fc);
                end
            otherwise % 'rect'
                fc = min(0.49, (Rchip/2)/(fs/2));
                h  = fir1(64, fc);
        end
        y  = filter(h,1,s);
    
        % Ensure we have enough samples, then crop to N
        if numel(y) < N
            y = repmat(y, ceil(N/numel(y)), 1);
        end
        y = y(1:N);
    
        % emulate “aliased/blurred NB from 9M” by decimating & LP back
        if logical(fget(P,'downsample_like_NB',0))
            q = max(2, round(Rchip/1e6));  % e.g., 9 for 9 Mcps
            try
                y = resample(y, 1, q);
            catch
                y = decimate(y, q);        % fallback if resample is unavailable
            end
            if numel(y) < N, y = repmat(y, ceil(N/numel(y)), 1); end
            y = y(1:N);
            y = filter(fir1(128, 0.035), 1, y);  % make it much thinner in the STFT

        end

        % --- NB: random vertical columns, baseline untouched outside windows ---
        if isfield(P,'nb_cols') && isfield(P.nb_cols,'enable') && P.nb_cols.enable
            y = apply_nb_columns(y, fs, P.nb_cols);
        end

        
                
            
        x = y .* exp(1j*2*pi*fOff*t);

    % -------- Linear chirp (saw/tri) with duty and reset blip --------
    case 'chirp'
        BW    = fget(P,'bw_Hz',25e6);
        Tper  = fget(P,'period_s',8e-6);
        shape = lower(fget(P,'shape','sawup'));      % 'sawup'|'sawdown'|'tri'
        fOff  = fget(P,'osc_offset_Hz',0);
        duty  = max(0,min(1,fget(P,'duty',1)));
        rblip = fget(P,'reset_blip_dB',0);

        Nper  = max(2, round(Tper*fs));
        idx   = (0:N-1).';
        idxIn = mod(idx, Nper);

        switch shape
            case 'sawdown', frac = 1 - idxIn/Nper;
            case 'tri'
                frac = idxIn/Nper; frac = 2*abs(frac - 0.5);
            otherwise
                frac = idxIn/Nper;
        end

        finst = (-BW/2) + BW*frac + fOff;

        if duty<1
            actN = round(duty*Nper);
            active = idxIn < actN;
            finst(~active) = fOff;
        end
        phase = 2*pi*cumsum(finst)/fs;
        x     = exp(1j*phase);

        if rblip>0
            spikes = (idxIn==0);
            amp    = 10^(rblip/20);
            x(spikes) = amp * x(spikes);
        end

        alpha = fget(P,'edge_win',0);
        if alpha>0, x = x .* my_tukeywin(N, min(max(alpha,0),1)); end

    % -------- Frequency hopping --------
        case 'fh'
            K      = fget(P,'num_tones',6);
            stepHz = fget(P,'step_Hz', 8e6);
            dwell  = fget(P,'dwell_s',  3e-6);
            contPh = logical(fget(P,'phase_continuous',0));
            hopJit = fget(P,'hop_jitter_Hz', 0.15*stepHz);
    
            % Frequencies centered around DC with large spacing
            fStart = -stepHz*(K-1)/2;
            freqs  = fStart + stepHz*(0:K-1);
    
            % Ensure several hops fit in N samples
            dwellN   = max(1, round(dwell*fs));
            minHops  = 6;
            dwellN   = min(dwellN, floor(numel(t)/minHops));
    
            x  = zeros(N,1);
            if contPh, phi = 0; end
            n = 1;
            while n<=N
                k  = randi(K);
                n2 = min(N, n+dwellN-1);
                tt = (n:n2).'/fs;
                fk = freqs(k) + hopJit*(2*rand-1);
    
                if contPh
                    seg = exp(1j*(phi + 2*pi*fk*(tt - tt(1))));
                    phi = angle(seg(end));
                else
                    seg = exp(1j*2*pi*fk*tt);
                end
    
                x(n:n2) = seg;
                n = n2 + 1;
        end


    % -------- Composite (handled in Channel, present for completeness) --------
    case 'composite'
        comps   = fget(P,'components',{}); w = fget(P,'weights',ones(1,numel(comps)));
        w       = w(:).'/max(1e-12, norm(w));
        x = zeros(N,1);
        for i=1:numel(comps)
            xi = jammer_factory(comps{i}, fs, N);
            x  = x + w(i) * (xi * exp(1j*2*pi*rand()));
        end
        S = fget(P,'spurs',struct('enable',false));
        if isstruct(S) && fget(S,'enable',false)
            M   = fget(S,'count',3);
            rel = fget(S,'rel_dB',-25);  g = 10^(rel/20);
            BW  = fget(S,'bw_Hz',[0.5e6, 3e6]);
            for m=1:M
                bwm = BW(1) + (BW(2)-BW(1))*rand();
                per = (6e-6 + 8e-6*rand());
                xi  = jammer_factory(struct('type','chirp','bw_Hz',bwm,'period_s',per), fs, N);
                x   = x + g * xi;
            end
        end

    otherwise
        error('jammer_factory: Unknown jammer type "%s"', typ);
end

% ----------------------- Optional RF front-end ----------------------------
FE = fget(P,'frontend',struct('enable',false));
if isstruct(FE) && fget(FE,'enable',false)
    x = apply_frontend(x, fs, FE);
end

% Normalize jammer power to 1 (channel will scale to JSR)
Pj = mean(abs(x).^2); if Pj<=0, Pj=1; end
x  = x / sqrt(Pj);
end

% ============================== helpers ==============================
function v = fget(S, name, default)
    if isstruct(S) && isfield(S,name) && ~isempty(S.(name))
        v = S.(name);
    else
        v = default;
    end
end

function h = try_firrcos(N, Fc, R, Fs)
    try
        h = firrcos(N, Fc, R, Fs, 'rolloff', 'sqrt');
    catch
        fc = min(0.49, (Fc*(1+R))/(Fs/2));
        h  = lp_fir(N, fc);
    end
end

function h = lp_fir(N, Wn)
% Hamming-windowed sinc LPF. Wn in (0..1) normalized to Nyquist.
    n = (0:N)'; M = N/2;
    m = n-M;
    h = zeros(size(n));
    for i=1:numel(n)
        if m(i)==0
            h(i) = 2*Wn;
        else
            h(i) = sin(2*pi*Wn*m(i)) / (pi*m(i));
        end
    end
    ham = 0.54 - 0.46*cos(2*pi*(0:N)'/N);
    h = h .* ham;
    h = h / sum(h);
end

function w = my_tukeywin(N, alpha)
% Minimal Tukey window (alpha in [0,1])
    if alpha <= 0
        w = ones(N,1); return
    elseif alpha >= 1
        w = hann(N); return
    end
    w = ones(N,1);
    per = alpha*(N-1)/2;
    for n=0:N-1
        if n < per
            w(n+1) = 0.5 * (1 + cos(pi*(2*n/(alpha*(N-1)) - 1)));
        elseif n > (N-1 - per)
            w(n+1) = 0.5 * (1 + cos(pi*(2*n/(alpha*(N-1)) - 2/alpha + 1)));
        else
            w(n+1) = 1;
        end
    end
end

function y = resample_like(x, p, q)
% Crude integer downsample approximation (p ignored, q>=1)
    if q<=1, y = x; return; end
    y = x(1:q:end);
    % zero-order hold back close to original scale (not perfect; good enough for “blur” effect)
    y = repelem(y, q);
end

% ======================= RF front-end modelling =======================
function x = apply_frontend(x, fs, FE)
% Keep it light and deterministic enough for dataset generation.

    N = numel(x);
    t = (0:N-1).'/fs;

    % --- DC offset (complex) ---
    dc = fget(FE,'dc_offset',0);
    if ~isempty(dc) && any(dc~=0), x = x + complex(dc); end

    % --- IQ imbalance (gain/phase) ---
    g_dB = fget(FE,'iq_gain_imbalance_dB',0);
    ph   = fget(FE,'iq_phase_deg',0);
    if g_dB~=0 || ph~=0
        g  = 10^(g_dB/20);
        th = ph*pi/180;
        xr = real(x); xi = imag(x);
        % Apply gain/phase error: rotate I/Q and scale I
        Ir = g.*xr;
        Qi = xi*cos(th) + xr*sin(th);
        x  = complex(Ir, Qi);
    end

    % --- Slow AM ripple (flicker-ish) ---
    Aflk = fget(FE,'amp_flicker_dB',0);
    if Aflk>0
        m   = 10^(Aflk/20);
        f0  = 40 + 80*rand();        % 40–120 Hz very slow ripple
        env = 1 + (m-1)*sin(2*pi*f0*t + 2*pi*rand());
        x   = x .* env;
    end

    % --- Phase noise (very light, single-corner model) ---
    PN = fget(FE,'phase_noise',struct());
    if isstruct(PN) && isfield(PN,'L_dBc_Hz') && isfield(PN,'f0_Hz')
        L1k = PN.L_dBc_Hz;  fcorner = max(1, PN.f0_Hz);
        % Convert a single-point L(f) to a crude white PM std per-sample
        % This is intentionally mild to avoid over-warping chirps.
        S_phi = 2*10^(L1k/10);      % very rough
        sigma = sqrt(S_phi*fs/max(fcorner,1)) * 1e-4;
        dphi  = sigma*randn(N,1);
        phi   = cumsum(dphi);
        x     = x .* exp(1j*phi);
    end

    % --- Small spurs (count, rel level, narrow swept) ---
    SP = fget(FE,'spurs',struct('enable',false));
    if isstruct(SP) && fget(SP,'enable',false)
        M   = max(1, fget(SP,'count',2));
        rel = fget(SP,'rel_dB',-28);   g = 10^(rel/20);
        BW  = fget(SP,'bw_Hz',[0.2e6, 1.0e6]);
        for m=1:M
            bwm = BW(1) + (BW(2)-BW(1))*rand();
            per = (6e-6 + 10e-6*rand());
            s   = exp(1j*2*pi*cumsum( (-bwm/2 + bwm*( (0:N-1)'/ (per*fs) - floor((0:N-1)'/(per*fs)) )) )/fs);
            x   = x + g*s .* exp(1j*2*pi*rand());
        end
    end

    % --- Soft clip / limiter to emulate AGC headroom ---
    dBFS = fget(FE,'softclip_dBFS',[]);
    if ~isempty(dBFS)
        a = 10^(dBFS/20);        % soft threshold
        mag = abs(x);
        x = x .* (tanh(mag/a) ./ max(mag, eps));
    end
end


function y = apply_nb_columns(y, Fs, C)
% Bright, thin columns on the NB line with minimal vertical spread.

    N  = numel(y);
    T  = N / Fs;

    % events per tile
    lambda = max(0, getf(C,'rate_per_us',0)) * 1e6 * T;
    K = max(0, round(poisson_like(lambda)));

    if K==0, return; end

    % strengths & shaping
    if isfield(C,'spike_dB')
        gain = max(0, 10^(C.spike_dB/20) - 1);
    else
        gain = max(0, getf(C,'gain',0.6));
    end
    beta   = max(0, getf(C,'beta',1.1));
    dev    = max(0, getf(C,'fm_dev_Hz',8e4));    % very small FM
    pstep  = max(0, getf(C,'phase_step_rad',1.6));
    talpha = min(max(getf(C,'tukey_alpha',0.015),0),1);
    tipw   = min(max(getf(C,'tip_weight',0.94),0),1);

    wmin   = max(1e-7, getf(C,'width_us_min',0.24)*1e-6);
    wmax   = max(wmin, getf(C,'width_us_max',0.45)*1e-6);

    env = ones(N,1);
    add = zeros(N,1);

    for k = 1:K
        W   = wmin + (wmax - wmin)*rand();
        % --- safe center + indices (exactly L samples, always 1..N) ---
% --- snap to STFT grid so each spike occupies ~1 time bin ---
SNP = getf(C,'snap_to_stft',struct('enable',false));
if isstruct(SNP) && getf(SNP,'enable',false)
    nperseg = getf(SNP,'nperseg',64);
    hop     = getf(SNP,'hop',8);               % 64 with 56 overlap → hop=8
    L       = max(8, min(round(0.9*nperseg), N-2));  % ~one frame wide
    % center on a hop boundary closest to a random position
    c_raw   = randi([ceil(L/2), N - ceil(L/2)]);
    c       = round(c_raw / hop) * hop;
    c       = min(max(c, ceil(L/2)), N - ceil(L/2));
else
    c = randi([ceil(L/2), N - ceil(L/2)]);
end

idx = (c - floor(L/2)):(c + ceil(L/2) - 1);
idx = idx(idx>=1 & idx<=N);   % robust clamp (avoid “Array indices…” errors)



        idx = (c-h1):(c+h2);    % length(idx) == L


        % Near-rect window + very sharp tip (normalized 0..1)
        w  = tukeywin(numel(idx), talpha); w = w / max(w);
        gg = exp(-0.5*(( (1:numel(idx))' - (numel(idx)+1)/2 ) / max(1,0.04*numel(idx))).^2);
        gg = gg / max(gg);
        w  = (1-tipw)*w + tipw*gg;

        % (1) multiplicative lift: makes the column as bright as baseline
        env(idx) = env(idx) .* (1 + gain * w);

        % (2) additive copy with tiny FM and a phase step at center
        if beta > 0
            tloc   = (0:numel(idx)-1)'/Fs;
            % almost-no FM → column stays near the line
            if dev>0
                df    = dev * (2*rand-1);
                seg   = y(idx) .* exp(1j*2*pi*df*(tloc - mean(tloc)));
            else
                seg   = y(idx);
            end
            % crisp PM "tick" at the peak
            center = round(numel(idx)/2);
            phi    = zeros(numel(idx),1);
            phi(center:end) = pstep;
            seg   = seg .* exp(1j*phi);

            % Favor PM (keeps energy tight), tiny FM
            add(idx) = add(idx) + beta * w .* (0.85*seg + 0.15*y(idx));
        end
    end

    y = y .* env + add;
end

function v = getf(S, name, default)
    if isstruct(S) && isfield(S,name) && ~isempty(S.(name)), v = S.(name); else, v = default; end
end

function k = poisson_like(lambda)
    if lambda <= 0, k = 0; return; end
    L = exp(-lambda);  p = 1;  k = 0;
    while p > L, k = k + 1; p = p * rand(); end
    k = k - 1;
end
